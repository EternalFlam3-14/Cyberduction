
~~~~~ VAULT ~~~~~
The vault will contain a limited number of items, although it can hold different types of items. If it has a general max capacity, it would be hard to keep track of how many of each item you have. If the items are put into slots that have individual capacities, you can have 12 different items with varying amounts of capacity, with easy handling and storage. The slots can expand in capacity, and the vault can expand in slots.
What is inherit to the design is the seperation of items, the expandability of the slots, but the increased workload and structure behind it. The expansive capabilities will have to be added in by hand, as the structure doesn't have special limitations. The ItemStacks will likely need a Slot or some other sort of wrapper to work in any system properly.
The vault will also have an I/O system, meaning the machines will interact with the interface to deposit and extract items from the vault. This will present some interesting things, as I will now need an itemstack to transfer items. If the vault takes multiple items, will it have an ItemStack instead of a vector<Items>? In which case, Vault will contain Slots which contain an ItemStack... which will wrap the ItemStack with a Capacity. If I dropped the Slots, then I'd have a Vault that contains Itemstacks and the Capacity of the Stacks, whether they be together or seperate.
Slots is probably a better option, as they can be reused in the machines with specific Capacities & maybe even extended to only hold specific items.

~~~~~ Items ~~~~~
Items will have their specific Item, and they will be categorized into an ItemType (Apples and wheat are both food itemtypes, while iron isn't).
What comprises an Item? If an item is an enum, then what gives them a count? The ItemStacks have a Count and Item value? I mean... yeah. Add or subtract Items from an ItemStack, it can't change it's Item, and once it hits 0 it's gone. 

~~~~~ ItemStacks ~~~~~~
ItemStacks are what give Items their "spatial" value. An ItemStack has a Count, and an Item. If the Stack hits 0, it will automatically deconstruct itself. The Count is a simple int value, and the Item is an Item. ItemStacks cannot change Items.

~~~~~ Slots ~~~~~
ItemTypes will be a defining factor of Slots, as each Slot will take a different Itemtype. How would I make a multi-purpose Slot? Maybe I could make a Constructor that creates a Slot without a given Itemtype that skips the Itemtype check... ItemType All = 0, if ItemType == 0 then skip ItemType check?
If a Slot has a given Item already stored in it, the Slot's Item is checked against before accepting the item. This is inherit in the system, as you would simply add the count of the Input ItemStack to the count of the Slot ItemStack, probably ItemStack-level, with access to that kind of checking.
Slot Item = Apple, Input Item = Wheat;
ItemType check passed, Item check failed;
Input rejected.

